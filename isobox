#!/usr/bin/python3

import sys
import os
import argparse
import traceback
import json
from libisobox.mnt import *
from libisobox.rootfs import *
from libisobox.unsquash_filesystem import *
from libisobox.chroot import *
from libisobox.filesystems import *
from libisobox.isobox_model import Isobox
from libisobox.isoboxmanagement import getboxbyname
from libisobox.checkdependencies import checkdependencies
from libisobox.purge import purge
from libisobox.cleanup_processes import cleanup_processes


def create_required_files():  # Create files used by isobox like config files if they dont exist
    if not os.path.exists("/var/lib/isobox"):
        os.mkdir("/var/lib/isobox")
    if not os.path.exists("/var/lib/isobox/isoboxes.json"):
        with open("/var/lib/isobox/isoboxes.json", "w") as f:
            json.dump([], f)
    if not os.path.exists("/var/lib/isobox/mounts"):
        os.mkdir("/var/lib/isobox/mounts")


def parse_args():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(help="Command", dest="command")
    subparsers.required = True

    createparser = subparsers.add_parser("create", help="Create new isobox")
    createparser.add_argument("name")
    createparser.add_argument("isopath")
    createparser.add_argument(
        "-sfs",
        "--sfspath",
        type=str,
        default=None,
        help="Path of the iso's squashfs relative to the iso's root",
    )

    removeparser = subparsers.add_parser("remove", help="Remove existing isobox")
    removeparser.add_argument("name")

    rmallparser = subparsers.add_parser(
        "purge",
        help="Remove all existing isoboxes and data related to isobox, usually to run before uninstalling",
    )

    infoparser = subparsers.add_parser("info", help="Print info about an isobox")
    infoparser.add_argument("name")

    mvparser = subparsers.add_parser(
        "move", help="Move an isobox to another directory on your system."
    )
    mvparser.add_argument("name")
    mvparser.add_argument("target")

    createparser.add_argument("-mountpoint", type=str, default=None)

    shellparser = subparsers.add_parser(
        "shell", help="Gain a shell into an existing isobox"
    )
    shellparser.add_argument("name")
    shellparser.add_argument(
        "-u",
        "--user",
        type=str,
        default="root",
        help="The user inside the isobox to start as",
    )

    runparser = subparsers.add_parser("run", help="Run program in an isobox")
    runparser.add_argument("name")
    runparser.add_argument("program")
    runparser.add_argument(
        "-u",
        "--user",
        type=str,
        default="root",
        help="The user inside the isobox to start as",
    )

    subparsers.add_parser("ls", help="List all isoboxes")

    guiparser = subparsers.add_parser("gui", help="Run existing isobox and start gui")
    guiparser.add_argument("name")
    guiparser.add_argument("-tty", type=str, default="3", help="The tty to startx into")
    guiparser.add_argument(
        "-display",
        type=str,
        default="2",
        help="The display to start the Xorg server on",
    )
    guiparser.add_argument(
        "-u",
        "--user",
        type=str,
        default="root",
        help="The user inside the isobox to start as",
    )

    return parser.parse_args()


def main(args):

    create_required_files()

    if args.command == "create":
        isopath = os.path.abspath(args.isopath)
        mountpoint = None

        if not args.mountpoint:
            mountpoint = f"/var/lib/isobox/mounts/{args.name}"
        else:
            mountpoint = args.mountpoint

        tempmount_iso(isopath)
        try:
            squashedpath = None
            if args.sfspath:
                squashedpath = "/tmp/isobox_mount/" + args.sfspath
            else:
                squashedpath = get_rootfs()
            unsquash(mountpoint, squashedpath)
        finally:
            subprocess.run(["umount", "/tmp/isobox_mount"])

        if not isroot(
            mountpoint
        ):  # Sometimes distributions leave an img file of the root filesystem in the squashfs, we need to handle that
            print(
                "No useable root in squashfs, looking for potential rootfs image file."
            )
            rootimg = find_rootimg(mountpoint)
            print(
                f"Potential rootfs image file found at {rootimg}, mounting it to /mnt!"
            )
            subprocess.run(f"mount -t auto {rootimg} /mnt".split())
            shutil.rmtree(mountpoint)

            print(f"Copying rootfs to {mountpoint}")

            subprocess.run(f"cp -R /mnt {mountpoint}".split())
            subprocess.run(f"umount /mnt".split())

        with open("/var/lib/isobox/isoboxes.json", "r+") as f:
            boxeslist = json.load(f)

            newisobox = Isobox(name=args.name, note="", mountpoint=mountpoint)
            boxeslist.append(newisobox.__dict__)
            f.seek(0)
            f.write(json.dumps(boxeslist))
            f.truncate()

        rootpath = mountpoint + "/root/"

        userhomes = os.listdir(mountpoint + "/home")
        userhomes = [
            i
            for i in userhomes
            if not i.startswith(".")
            and ".config" in os.listdir(mountpoint + "/home/" + i)
        ]

        if len(userhomes) == 1 and os.path.exists(
            mountpoint + "/home/" + "/" + userhomes[0]
        ):
            print("Found user in iso's root...")
            configpath = mountpoint + "/home/" + "/" + userhomes[0] + "/.config"
            answer = input(
                f"A user's home directory was found on the live system at /home/{userhomes[0]} would you like to copy this user's .config to the /root directory? It may be necessary in order to have the distro's custom desktop environment config when entering the gui [Y/N]: "
            ).lower()
            if answer in ("y", "yes"):
                if os.path.exists(rootpath + "/.config"):
                    shutil.rmtree(rootpath + "/.config")
                subprocess.run(f"cp -R {configpath} {rootpath}".split())
                print("Done!")
        elif len(userhomes) > 1:
            x = 1
            for i in userhomes:
                print(f"{x}: {'/home/' + i}")
                x += 1
            answer = input(
                "Several user homes were found in the iso, do you want to copy the .config of one of them to the root directory? It may be useful to have some of the distro's config like the desktop environment customizations. (number/n):"
            ).lower()
            if answer.isdigit():
                userhome = userhomes[int(answer) - 1]
                configpath = mountpoint + "/home/" + userhome + "/.config"
                if os.path.exists(rootpath + "/.config"):
                    shutil.rmtree(rootpath + "/.config")
                subprocess.run(f"cp -R {configpath} {rootpath}".split())
                print("Done!")

    elif args.command == "shell":
        currentbox = getboxbyname(args.name)

        mount_filesystems(currentbox["mountpoint"])
        chroot(currentbox["mountpoint"], args.user)

    elif args.command == "gui":
        currentbox = getboxbyname(args.name)

        mount_filesystems(currentbox["mountpoint"])
        chroot_gui(currentbox["mountpoint"], args.tty, args.display, args.user)
    elif args.command in ("ls", "list"):
        boxeslist = None
        with open("/var/lib/isobox/isoboxes.json", "r+") as f:
            boxeslist = json.load(f)
        if len(boxeslist) == 0:
            sys.exit("No isoboxes on this system.")
        else:
            for i in boxeslist:
                print(i["name"])
    elif args.command == "remove":
        currentbox = getboxbyname(args.name)
        print(f"Deleting isobox {args.name}")
        try:
            shutil.rmtree(currentbox["mountpoint"])
        except FileNotFoundError:
            pass
        finally:
            print(f"Deleting entry for isobox {args.name}")

            with open("/var/lib/isobox/isoboxes.json", "r+") as f:
                boxeslist = json.load(f)
                toremove = [i for i in boxeslist if i["name"] == args.name]

                boxeslist[:] = [i for i in boxeslist if i["name"] != args.name]
                f.seek(0)
                f.write(json.dumps(boxeslist))
                f.truncate()
    elif args.command == "move":
        currentbox = getboxbyname(args.name)
        currentmountpoint = currentbox["mountpoint"]
        target = os.path.abspath(args.target)

        subprocess.run(f"mv {currentmountpoint}/* {target}", shell=True)

        with open("/var/lib/isobox/isoboxes.json", "r+") as f:
            boxeslist = json.load(f)
            tomove = [i for i in boxeslist if i["name"] == args.name][0]
            tomove["mountpoint"] = target
            f.seek(0)
            f.write(json.dumps(boxeslist))
            f.truncate()
    elif args.command == "info":
        currentbox = getboxbyname(args.name)
        print(f"Info about box {currentbox['name']}:\n")
        print(f"Name: {currentbox['name']}")
        print(f"Mountpoint: {currentbox['mountpoint']}")
        print(f"Note: {currentbox['note']}")
    elif args.command == "purge":
        answer = input(
            "Are you sure you want to delete all data related to isobox? [Y/n]: "
        ).lower()
        if answer in ("y", "yes"):
            purge()
        else:
            sys.exit("Aborting")
    elif args.command == "run":
        currentbox = getboxbyname(args.name)

        mount_filesystems(currentbox["mountpoint"])
        chroot_run(currentbox["mountpoint"], args.user, args.program)


if __name__ == "__main__":
    args = parse_args()

    if (
        os.getuid() != 0
    ):  # Quit if user is not root as root is pretty much required for this to run properly
        sys.exit("Requires root")
    checkdependencies()  # Check if unsquashfs is installed basically

    currentmountpoint = None
    # Set the currentmountpoint here so we can unmount mounted filesystems  here if something goes south
    if args.command in ("shell", "gui", "run") and getboxbyname(args.name):
        currentmountpoint = getboxbyname(args.name)["mountpoint"]

    try:
        main(args)
    except Exception as e:
        print(traceback.format_exc())

    finally:
        if currentmountpoint:
            umount_filesystems(currentmountpoint)
            cleanup_processes(currentmountpoint)
